; 10A
(define (big x) (> x 5))

(define ints (list 1 10 3 8 4 7))
(define ints1 (cdr ints))

(define (filter! f s)
	(define (filter1 f s l)
		(cond ((null? (cdr s)) (cdr l))
			((not (f (cadr s))) (set-cdr! s (cddr s)) (filter1 f s l))
			(else (filter1 f (cdr s) l))
			)
		)
	(filter1 f s s)
	)

; 11A
(define (count-change total denoms max-coins)
	(cond ((eq? total 0) 1)
		((eq? max-coins 0) 0)
		((null? denoms) 0)
		((>= total (car denoms)) (+ (count-change total (cdr denoms) max-coins) (count-change (- total (car denoms)) denoms (- max-coins 1))))
		(else (count-change total (cdr denoms) max-coins))
		)
)

; 12
(define (list-partitions total max-pieces max-value)
	
	(define (constructor target sofar lis) ;if functioning correctly this should create all the partitions, but with duplicates
		(cond ((eq? target sofar) (list lis))
			(else (append (constructor target (+ 1 sofar) (append '(1) lis)) (constructor target (+ 1 sofar) (append (list (+ 1 (car lis))) (cdr lis)))))
		)
	) ;order and filter or figure out how to write for loops recursively
	
	(define (sort l)
		(cond ((null? l) '())
			(else (cons (smallest l (car l)) (sort (remove l (smallest l (car l))))))
			)
		)
	(define (remove l x)
		(cond ((null? l) '())
			((= (car l) x) (cdr l))
			(else (cons (car l)(remove (cdr l) x)))
			)
		)
	(define (smallest l a)
		(cond ((null? l) a)
			((< (car l) a) (smallest (cdr l) (car l)))
			(else (smallest (cdr l) a))
			)
		)
	
	(define (mapping f l result)
		(cond ((null? l) result)
			(else (mapping f (cdr l) (append result (list (f (car l))))))
			)
		)
	(define (filter f l result)
		(cond ((null? l) result)
			((f (car l)) (filter f (cdr l) (append result (list (car l)))))
			(else (filter f (cdr l) result))
			)
		)
	
	(define (range low high)
		(cond ((> low high) '())
			(else (append (list low) (range (+ low 1) high)))
			)
		)
	
	(define (equal-list x y)
		(cond ((not (= (length x) (length y))) #f)
			((and (null? x) (null? y)) #t)
			((= (car x) (car y)) (equal-list (cdr x) (cdr y)))
			(else #f)
			)
		)
	(define (in x l)
		(cond ((null? l) #f)
			((equal-list x (car l)) #t)
			(else (in x (cdr l)))
			)
		)
	
	(define (remove-dup l result)
		(cond ((null? l) result) 
			((in (car l) result) (remove-dup (cdr l) result))
			(else (remove-dup (cdr l) (append result (list (car l)))))
			)
		)
	
	(define (max-val l)
		(cond ((null? l) #t)
			((> (car l) max-value) #f)
			(else (max-val (cdr l)))
			)
		)
	
	(define lis (constructor total 1 '(1)))
	
	(filter max-val (filter (lambda (x) (<= (length x) max-pieces)) (remove-dup (mapping sort lis '()) '()) '()) '())
)
